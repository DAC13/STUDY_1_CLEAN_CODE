# 스터디 기록

## 일시 및 장소

- 일시: 2024년 06월 09일(일요일) 20:00 ~ 22:30(2시간30분)
- 장소: 온라인(Google meet)

## 참여자

@SeungHyunP @whdkwhdk90 @mmmmicha

## 내용

### 8장 - 경계

- 광현: 가장 작은 단위의 기본 라이브러리 유틸코드들 조차도 될 수 있으면 직접사용을 줄이고 감싸서 사용하자. 그에 대한 방법으론 새로운 클래스로 경계 감싸기가 있겠다.
- 광현: 학습테스트의 유효성을 느꼈다.
- 광현: 지금까지 라이브러리를 적용할 때 유사한 사용방식을 구글링하여 그대로 붙여넣어 직접 테스트를 돌려보기 쉽상이었는데 직접 테스트코드를 짜봄으로써 라이브러리에 대한 wrapping class를 만들 수 있음을 확인했다.
- 승현: 기존에 쓰던 라이브러리를 테스트코드를 작성해서 사용한다는 게 신선했다. 실제로 테스트코드를 짜본적이 있는가?
- 광현: nodejs 진영의 orm 툴인 prisma library를 wrapping클래스를 통해 wrapping한 후 repository에서 해당 클래스를 사용하면서 이를 테스트코드로 짜고 있다.(엄밀히 따지면 wrapping 클래스에 대한 테스트코드는 없다(레거시))
- 승현: 외부 API에 대한 테스트 코드만 일부있고 내부 비즈니스에 대한 테스트 코드는 아직 없다. 이 부분이 책을 읽으면서 아쉽긴했다.
- 승현: 어댑터 패턴이 뭔지 몰랐음. 호환되지 않는 API를 연결하는 디자인 패턴을 의미하더라. 해당 패턴을 직접 사용해 코드룰 작성해보고 싶다. 지금까지 패턴에 대해 제대로 인지하지 못한채 코드들을 작성해왔는데 그간 작성했던 코드 중 어댑터 패턴을 우연히 사용한 경우들이 있었는지 확인해보고 싶다.
- 광현: 좋은 아키텍쳐일수록 자연스럽게 디자인패턴을 품고 있기 마련인데 이렇게 공부한 후 현업 코드 확인을 통해 우연히 사용되고 있었는지 확인해보는 건 재밌을 것 같다.
- 승현: 클린아키텍처에서 다루던 SOLID원칙이 다뤄지고 있어서 도움이 되었다. 좋은 시너지가 나고 있는 듯 하다.
- 준혁: 무슨말인지는 다 알겠는데, 스택오버플로우 같은 곳들을 참고해서 담습하기 마련인데 공식적인 사이트를 통해 알아보려는 노력보다는 직접 참고해서 사용하기 때문에 문제발생이 어떤식으로 일어날지 확인할 수가 없었다. 나의 경우도 테스트코드를 거의 작성을 안한다. 나는 솔직히 테스트 코드를 어떻게 작성하는지도 잘 모른다. 테스트 코드를 작성하는 습관을 들여야겠다.
- 준혁: 안전한 요소와 불안전한 요소를 나누는 것이 결국 이번장에 핵심인 것 같다. 외부 API들은 불안정한 요소들로 분류가 된다. 이걸 래핑함으로써 안전한 요소로 만드는 과정이 될 수 있겠다.

### 9장 - 단위 테스트

- 광현: 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 테스트 코드가 없는 리팩터링은 그저 버그를 양산하는 행위이다.
- 광현: 테스트 코드가 방치되어 망가지면 실제 코드도 망가진다.
- 광현: 테스트 코드를 현업에서 직접 작성해보면서 느끼는 게 많았다. 테스트코드를 짜기 시작하니까 기존에 단순 신뢰로 작성하던 코드들이 다 위험요소로 보이고, 팀원들이 테스트코드를 안짜주면 필요이상으로 코드를 디테일하게 봐야하여 코드리뷰 시간이 너무 늘어나고 그 코드를 온전한 신뢰로 승인 해줄수가 없다. 아직은 계도기간이다 보니 테스트코드 작성을 강제할 수는 없다. 이전에 현업에서 테스트 코드 없이 리팩터링을 했었다가 배포에서 문제가 생겼던 적이 있었고 그 이후 다시 한번 테스트 코드 없는 리팩터링은 오히려 버그를 양산하는 행위라는 사실을 뼈저리게 느꼈다.
  - 승현: 코드리뷰에 대한 방식이 어떤식으로 되는가? 테스트코드도 PR에 함께 올리는가? 그 테스트코드도 세부적으로 살펴보는가?
    - 광현: 테스트코드까지 함께 올라간 PR을 리뷰한다. 테스트코드를 완전 세부적으로 보진 못한다. 대략적으로 필요한 테스트 케이스들이 작성되었는지 확인을 하는 편이다. 너무 시간이 촉박하면 테스트 코드의 로직을 전부 볼 수 없어서 테스트코드를 돌려보기만 할 때도 있다. 거의 경계테스트를 많이 한다.
    - 준혁: 테스트코드를 작성하고 비즈니스 로직을 작성하는데, 이럴 경우 테스트코드를 무수히 많이 돌려보게 될 텐데, 하루에 얼마나 많은 코드들을 짜게 되는가? 대부분의 중소기업에서 테스트코드를 멀리하는 이유가 작업량이 많아진다는 생각때문인데..
      - 광현: 일단 당연히 물리적인 량 자체는 더 많지 않을까 싶다. `테스트 코드가 작업량을 늘린다` 라는 말은 오해인 것 같다. 테스트 코드를 작성한다는 것 자체가 해당 로직에 대한 충분한 고민과 이해가 바탕이 된다. 이렇게 작성된 테스트 코드와 로직은 사이드 이펙트가 굉장히 적다. 하지만 충분히 고민하는 시간을 거치지 않고 심지어 테스트 코드까지 없는 코드는 QA시에나 실서비스시에 수많은 문제들이 터질 수 있다. 이러한 문제들을 수습하는 시간들이 쌓일 떄 결국 테스트 코드 작성에 사용된 시간을 훌쩍 넘어서는 경우들이 허다하다. 테스트 코드 외에 내가 작성한 코드가 옳다라는 주장자체를 과연 어떻게 할 수 있을까?
- 승현: DSL이란 도메인에 대한 특별한 용어들을 풀어서 설명해서 다른 개발자들이 봤을 때도 이해할 수 있도록 나타내는 것인 것 같다?
- 승현: 이번 장을 공부하면서 테스트 코드를 더 작성해보고 싶다라는 생각이 들었다.
  - 광현: 테스트 코드 작성을 막 시작하게 되면서 할 수 있는 실수가 있다.
    1. 기존 레거시 코드에 테스트를 달아볼려고 시도한다.
       - 기존 레거시 코드들(특히, 비즈니스 레이어)은 여러 이상적인 원칙들을 따르지 않은 채 덩어리로 작성된 경우가 허다하기 때문에 테스트를 작성하다 지칠 수도 있다.
       - 위에 대한 대안으로 `e2e테스트`를 우선으로 짜는 걸 추천한다. API단위로 테스트를 짜고 단위 테스트는 새로운 기능들 위주로 붙여나가면 좋을 것 같다.

### 10장 - 클래스

- SRP가 뭔가?

  - 승현: SRP를 이해하기 위해 SRP가 제대로 지켜지지 않았을 때 발생하는 문제 케이스를 알아보는 방법이 있다.

    ```ts
    class Test {
      public method1() {
        ...
        (new Test2()).method2();
        ...
      };
    }

    class Test2 {
      public method2() {};
    }

    class Test3 {
      public method3() {
        ...
        (new Test2()).method2();
        ...
      };
    }
    ```

    위와 같이 `method2()`를 `method1()`, `method3()`에서 모두 내부 구현에 사용하고 있는데, method1()의 구현을 조금 수정하기 위해 method2()의 구현을 수정하게 될 경우, method3()는 method2()가 수정된 것을 알지 못하기 때문에 버그를 일으키게 될 수도 있다. 이 경우 `Test`와 `Test3`는 SRP를 위반한 경우가 된다.

- OCP가 뭔가?

  - 광현: 추상화된 인터페이스나 추상클래스가 있을 때 해당 부모들(앞의 인터페이스나 추상 클래스)을 기반으로 수많은 파생 클래스들이 생겨나는 것에는 열려있으나 해당 부모들이 수정되서는 안되는 즉, 수정에는 닫혀있어야 한다는 원칙을 말한다.

- DIP가 뭔가?

  - 광현: 의존성 역전은 의존성을 구체에서 추상화로 옮겨가는 것을 의미한다는 승현이의 메모가 핵심인 것 같다. DIP설명을 위해 아래와 같은 예시를 동원하고 싶다.

    ```ts
    class CofferController {
      // 명시적 의존성
      public async order() {
        ...
        const coffeeService: CoffeeService = new AmericanoService();
        await coffeeService.order();
        ...
      }

      // 추상화에 의존
      constructor(private readonly coffeeService: CoffeeService) {}
      public async order() {
        ...
        await this.coffeeService.order();
        ...
      }
    }

    interface CoffeeService {
      public order();
    }
    ```

    Controller에서 AmericanoService에 명시적으로 의존성을 갖게 된다면 의존성의 방향이 `Controller -> AmericanoService`가 되는데, Controller와 Service사이에 추상화(CoffeeService)가 들어오게 된다면 `Controller -> CoffeeService <- AmericanoService`가 되면서 의존성의 역전이 일어난다.

- 높은 응집도란 무엇인가?

  - 광현: `승현` 이라는 객체가 `성대`라는 멤버 변수를 가지고 있다. 이에 맞게 `노래부르기`라는 메서드를 가지고 있다면 `승현`이라는 객체는 응집도가 높은 것이다. 하지만 `노래부르기`대신 `타자치기`라는 `성대`멤버변수와 관련이 없는 메서드를 가지게 된다면 응집도는 낮은 것이다. 이렇게 될 경우 응집도를 높이기 위해 객체를 분리할 수 있다.

- 낮은 결합도란 무엇인가?

  - 광현: 아래 예시를 보겠다.

    ```ts
    public async validate(id: number, name: string, age: number) {
      ...
      // 결합도 매우 높음
      this.validatePerson(id, name, age);
      // 결합도 상대적으로 낮음
      this.validateAge(age);
    }

    public async validatePerson(id: number, name: string, age: number) {
    }

    public async validateAge(age: number) {}
    ```

    위 예시는 인수를 통해 결합도를 나타내본 단적인 예시이다. 결론은 `의존성이 강한 코드가 결국 결합도가 높은 `코드이다.

### 11장 - 시스템

- 광현: 소프트웨어 시스템은 (애플리케이션 객체를 제작하고 의존성을 서로 연결하는) 준비 과정과 (준비 과정 이후에 이어지는) 런타임 로직을 분리해야 한다. 결국 단적으로 controller와 service를 봤을 때 controller에서 명시적 의존성을 갖고 객체를 생성하든 Factory를 통해 객체를 생성하든 만들어진 객체를 service에 인수로 넘겨줌으로써 service는 준비과정없이 바로 런타임 로직에 착수할 수 있다. 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.
- 광현: 의존성 주입에 대해 설명할 수 있나?
- 광현: 횡단 관심사에 대해 제대로 이해했나?
- 승현: ABSTRACT FACTORY 패턴을 좀 더 공부해보고 싶다.
- 준혁: 준비 과정과 런타임 로직을 분리해야한다라는 내용이 중요하다고 느꼈다. AOP는 잘 모르겠다.

### 12장 - 창발성

- 광현: 클래스와 함수 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 뜻이다.
- 준혁: 내용은 다 좋은데 결국 많이 코드를 써봐야하는 것 같다. 많이 분리를 해봐야 한다.
- 승현: 창발성이 무슨 뜻인지 궁금해서 찾아봤더니 갑자기 떠오른다 이런 뜻이더라. 개발에 적용해보면 단순한 결합이 복잡한 결과를 나타낸다를 의미한다. 하위단계에서 하나하나 맞춰서 하게 되면 상위단계에서 좋은 결과를 얻을 수 있다라는 뜻으로 이해했다.
- 승현: 결국 여기에도 테스트 코드의 중요성이 대두되고 있다. 테스트코드를 작성해야한다.

### 13장 - 동시성

- 광현: 자료를 캡슐화하라. 공유자료를 최대한 줄여라. 될 수 있으면 readonly 데이터의 접근하는 경우들은 멀티스레딩을 사용해도 무방하다.
- 광현: 보조코드를 통해 강제로 실패하게 해보기. 흔들기 기법이 유효하다.
- 승현: 현업에서 동시성 컨트롤을 하고 있다. 만석이 되면 더이상 예약이 불가능해야하고, 미리 예약같은 경우엔 동시예약이 가능해야한다. 한 버스에 대한 마감이 10초 정도만에 된다. DB level에서 lock을 걸어서 해결을 한다.
  - 광현: 엄밀히 따지면 동시성을 제한하는 케이스인 것 같다. 결국 의도하지 않은 동시성을 미연에 방지하기 위해 제한하는 것도 동시성을 이해하는 길 중 하나라고 생각한다.

## 느낀점

- @mmmmicha: 물리적인 분량자체는 2회차와 비슷했으나 깊게 공부해봐야할 내용들이 많아서 예상 종료 시간보다 1시간이 오바됐다. 결국 내용들에 대해 깊이있게 생각할 시간을 갖는 것이 중요하기에 내용이 어렵다 싶으면 중간에 함께 얘기를 나누면서 분량을 조절하는 것도 방법이 될 수 있을 것 같다.

## 다음 일정

- 일시: 2024년 06월 13일 22시 - 1시간 30분 소요 예상
- 장소: 온라인(Discord) or google meet(1시간 제한)
- 목표: `14장 점진적인 개선` 까지 공부하기(시간이 충분하다면 `10장 클래스`, `11장 시스템` 한번 더 공부하기)
- 다음 서기: @whdkwhdk90
